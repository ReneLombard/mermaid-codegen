// Import the parser (this will be a JavaScript file generated by Jison)
const classDiagramParser = require('./classDiagramParser.js');

interface ParserYY {
    namespaces: { [namespace: string]: { [className: string]: ClassData } };
    currentNamespace?: string;
    addNamespace: (namespace: string) => void;
    setDirection: () => void;
    addClass: (className: string) => void;
    addMembers: (className: string, members: string[]) => void;
    addRelation: (relation: Relation) => void;
    cleanupLabel: (label: string) => string;
    addClassesToNamespace: (namespace: string, classes: string[]) => void;
    relationType: {
        EXTENSION: string;
        COMPOSITION: string;
        AGGREGATION: string;
        ASSOCIATION: string;
        DEPENDENCY: string;
        REALIZATION: string;
    };
    lineType: {
        LINE: string;
        DOTTED_LINE: string;
    };
}

interface InternalParser {
    yy: ParserYY;
    parse: (input: string) => void;
}

export class MermaidClassDiagramParser {
    private readonly internalParser: InternalParser;
    private namespaces: {
        [namespace: string]: { [className: string]: ClassData };
    } = {};
    private currentNamespace: string = '';
    private relationComments: { [relationKey: string]: string } = {};
    private attributeComments: { [attributeKey: string]: string } = {};

    constructor() {
        this.internalParser = classDiagramParser.parser;
        this.initializeParser();
    }

    public parse(mermaidContent: string): void {
        try {
            // Pre-process the content to capture comments
            this.preprocessContent(mermaidContent);
            this.internalParser.parse(mermaidContent);
        } catch (error) {
            throw new Error(`Error parsing Mermaid content: ${(error as Error).message}`);
        }
    }

    private preprocessContent(content: string): void {
        const lines = content.split('\n');
        let lastComment = '';
        let currentClass = '';
        let currentNamespace = '';

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Track current namespace
            if (line.startsWith('namespace ')) {
                currentNamespace = line.match(/namespace\s+(\w+)/)?.[1] || '';
                continue;
            }

            // Track current class
            const classMatch = line.match(/class\s+(\w+)/);
            if (classMatch) {
                currentClass = classMatch[1];
                continue;
            }

            // Capture comment lines
            if (line.startsWith('%%')) {
                lastComment = line.substring(2).trim();
                continue;
            }

            // Check for relation lines
            const relationPattern =
                /(\w+)\s*((?:[\|\}o][\|\-]*[\|\{o><])|(?:--[\>o])|(?:\.\.[\>o])|(?:==[\>o])|(?:<--)|(?:<\.\.)|(?:<==))\s*(\w+)(?:\s*:\s*(\w+))?/;
            const relationMatch = relationPattern.exec(line);

            if (relationMatch) {
                const [_, sourceClass, _relationSymbol, targetClass, relationName] = relationMatch;

                if (lastComment) {
                    const relationKey = `${sourceClass}-${targetClass}-${relationName}`;
                    this.relationComments[relationKey] = lastComment;
                    console.log(`Stored relation comment: ${relationKey} -> ${lastComment}`);
                }

                lastComment = '';
                continue;
            }

            // Check for attribute lines (inside a class)
            if (currentClass) {
                const attributePattern = /([+\-#~])\s*([\w<>~,\[\]\s\.\?]+)\s+(\w+)/;
                const attributeMatch = attributePattern.exec(line);

                if (attributeMatch) {
                    const [_, _scopeSymbol, _type, attributeName] = attributeMatch;

                    if (lastComment) {
                        const attributeKey = `${currentNamespace}-${currentClass}-${attributeName}`;
                        this.attributeComments[attributeKey] = lastComment;
                        console.log(`Stored attribute comment: ${attributeKey} -> ${lastComment}`);
                    }

                    lastComment = '';
                    continue;
                }
            }

            // Reset comment if we encounter other non-empty, non-comment lines
            if (line && !line.startsWith('classDiagram') && !line.includes('{') && !line.includes('}')) {
                lastComment = '';
            }
        }
    }

    public getParseOutcome(): {
        [namespace: string]: { [className: string]: ClassData };
    } {
        return this.namespaces;
    }

    addNamespace(namespace: string) {
        if (!this.namespaces[namespace]) {
            this.namespaces[namespace] = {};
        }
        this.currentNamespace = namespace; // Set the current namespace
    }

    addClass(className: string) {
        const currentNamespace = this.currentNamespace || 'global';
        if (!this.namespaces[currentNamespace]) {
            this.namespaces[currentNamespace] = {};
        }
        if (!this.namespaces[currentNamespace][className]) {
            this.namespaces[currentNamespace][className] = {
                Name: className,
                Namespace: currentNamespace,
                Type: 'Class',
                Attributes: {},
                Methods: {},
                Dependencies: {},
                Compositions: {},
                Aggregations: {},
                Associations: {},
                Realizations: {},
                Implementations: {},
                Inheritance: {},
                Lines: {},
                DashedLinks: {},
                Options: [],
            };
        }
    }

    addMembers(className: string, members: string[]) {
        const currentNamespace = this.currentNamespace || 'global';
        if (this.namespaces[currentNamespace]?.[className]) {
            members.reverse();

            members.forEach((member: string) => {
                const trimmedMember = member.trim();

                const matchMethod = trimmedMember.match(/([+\-#~])\s*(\w+)\s*\(([^)]*)\)\s*:\s*([\w~<>,\s]+)/);
                const matchAttribute = trimmedMember.match(
                    /([+\-#~])\s*([\w<>~,\[\]\s\.\?]+)\s+(\w+)\s*(?:=\s*([^;]*))?;*([\*\$]*)*?$/,
                );
                const matchType = trimmedMember.match(/<<(.*?)>>/);
                const matchOption = trimmedMember.match(/^(\w+)(?:\s*=\s*(\w+))?$/);

                if (matchType) {
                    const type = matchType[1]; // Extract the matched type
                    this.namespaces[currentNamespace][className].Type = type;
                } else if (matchOption) {
                    const option: OptionData = {
                        option: {
                            Name: matchOption[1],
                            Value: matchOption[2],
                        },
                    };

                    this.namespaces[currentNamespace][className].Options.push(option);
                } else if (matchMethod) {
                    const [_, scopeSymbol, name, methodArgs, returnType] = matchMethod;
                    const scopeMap: { [key: string]: string } = {
                        '+': 'Public',
                        '-': 'Private',
                        '#': 'Protected',
                        '~': 'Package',
                    };
                    const scope = scopeMap[scopeSymbol] || 'Public';

                    // Get the captured comment for this attribute
                    const attributeKey = `${currentNamespace}-${className}-${name}`;
                    const comment = this.attributeComments[attributeKey] || '';

                    if (methodArgs) {
                        // Add method
                        this.namespaces[currentNamespace][className].Methods[name] = {
                            Type: returnType,
                            Scope: scope,
                            Classifiers: '',
                            Arguments: methodArgs.split(',').map((arg: string): ArgumentData => {
                                const [argType, argName] = arg.trim().split(/\s+/);
                                return {
                                    Type: argType,
                                    Name: argName,
                                };
                            }),
                            Comment: comment,
                        };
                    } else {
                        this.namespaces[currentNamespace][className].Methods[name] = {
                            Type: returnType,
                            Scope: scope,
                            Classifiers: '',
                            Comment: comment,
                        };
                    }
                }
                //Attribute: - attributeName: type
                else if (matchAttribute) {
                    const [_, scopeSymbol, type, name, value] = matchAttribute;
                    const scopeMap: { [key: string]: string } = {
                        '+': 'Public',
                        '-': 'Private',
                        '#': 'Protected',
                        '~': 'Package',
                    };

                    // Get the captured comment for this attribute
                    const attributeKey = `${currentNamespace}-${className}-${name}`;
                    const comment = this.attributeComments[attributeKey] || '';

                    const scope = scopeMap[scopeSymbol] || 'Public';
                    let newString = trimmedMember;
                    // Remove the first character if it is +, -, #, ~
                    if (['+', '-', '#', '~'].includes(newString.charAt(0))) {
                        newString = newString.substring(1).trim();
                    }
                    // Remove text from the space
                    newString = newString.split(' ')[0];
                    // Add attribute
                    this.namespaces[currentNamespace][className].Attributes[name] = {
                        Type: newString,
                        IsSystemType: !!type.match(/^[A-Z]/),
                        Scope: scope,
                        DefaultValue: value ?? '',
                        Comment: comment,
                    };
                }
            });
        } else {
            console.warn(
                `Warning: Attempted to add members to class "${className}" in namespace "${currentNamespace}", but it does not exist.`,
            );
        }
    }

    addRelation(relation: Relation) {
        let { id1, id2, relation: relationType, relationTitle2: multiplicity, title } = relation;
        for (const ns of Object.values(this.namespaces)) {
            for (const className of Object.values(ns)) {
                if (className.Name === id1 || className.Name === id2) {
                    const sourceId = className.Name === id1 ? id1 : id2;
                    const targetId = className.Name === id1 ? id2 : id1;

                    let relationName = targetId;
                    // Check if title contains a colon and extract the name after it
                    if (title?.includes(':')) {
                        relationName = title.split(':')[1].trim();
                    }

                    // Get the captured comment for this relation
                    const relationKey = `${id1}-${id2}-${relationName}`;
                    const comment = this.relationComments[relationKey] || '';

                    let multiplicityType = '';
                    if (multiplicity?.includes(' ')) {
                        const parts = multiplicity.split(' ');
                        multiplicity = parts[0];
                        multiplicityType = parts[1].replace('[', '').replace(']', '');
                    }

                    const relationEntry: RelationData = {
                        Multiplicity: multiplicity,
                        MultiplicityType: multiplicityType,
                        Description: title ? title.replace(':', '').trim() : '',
                        LineType: relationType.lineType.toLowerCase().replace('_', ''),
                        Target: targetId,
                        Comment: comment,
                    };

                    const relationDirection = className.Name === id1 ? relationType.type2 : relationType.type1;

                    if (relationDirection === 'composition') {
                        ns[sourceId].Compositions[relationName] = relationEntry;
                    } else if (relationDirection === 'aggregation') {
                        ns[sourceId].Aggregations[relationName] = relationEntry;
                    } else if (relationDirection === 'dependency' && relationType.lineType === 'line') {
                        ns[sourceId].Associations[relationName] = relationEntry;
                    } else if (relationDirection === 'realization') {
                        ns[sourceId].Realizations[relationName] = relationEntry;
                    } else if (relationDirection === 'inheritance' || relationDirection === 'extension') {
                        ns[sourceId].Inheritance[relationName] = relationEntry;
                    } else if (relationDirection === 'implementation') {
                        ns[sourceId].Implementations[relationName] = relationEntry;
                    } else if (relationDirection === 'line') {
                        ns[sourceId].Lines[relationName] = relationEntry;
                    } else if (relationDirection === 'dottedline') {
                        ns[sourceId].DashedLinks[relationName] = relationEntry;
                    } else if (relationDirection === 'dependency' && relationType.lineType === 'dotted_line') {
                        ns[sourceId].Dependencies[relationName] = relationEntry;
                    }
                }
            }
        }
    }

    addClassesToNamespace(namespace: string, classes: string[]) {
        this.addNamespace(namespace); // Ensure namespace is created
        this.currentNamespace = namespace;
        classes.forEach((className: string) => this.addClass(className));
    }

    cleanupLabel(label: string): string {
        return label.trim();
    }

    initializeParser() {
        const self = this;

        this.internalParser.yy = {
            namespaces: {},

            addNamespace: function (namespace: string): void {
                self.addNamespace(namespace);
            },

            setDirection: function (): void {},

            addClass: function (className: string): void {
                self.addClass(className);
            },

            addMembers: function (className: string, members: string[]): void {
                self.addMembers(className, members);
            },

            addRelation: function (relation: Relation): void {
                self.addRelation(relation);
            },

            cleanupLabel: function (label: string): string {
                return self.cleanupLabel(label);
            },

            addClassesToNamespace: function (namespace: string, classes: string[]): void {
                self.addClassesToNamespace(namespace, classes);
            },

            relationType: {
                EXTENSION: 'extension',
                COMPOSITION: 'composition',
                AGGREGATION: 'aggregation',
                ASSOCIATION: 'association',
                DEPENDENCY: 'dependency',
                REALIZATION: 'realization',
            },

            lineType: {
                LINE: 'line',
                DOTTED_LINE: 'dotted_line',
            },
        };
    }
}
